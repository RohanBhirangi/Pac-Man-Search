# Search and Pac-Man

## Uninformed search
The aim of Pac-Man is to move away from the ghosts without caring about the pills. A class Node stores the Game State, the move to get to the state and a boolean stating whether the node has been visited or not. getStateValue() gives the distance of the Pac-Man from its closest ghost and a depth of 5 is allowed for the trees. In Breadth-First Search, a FIFO queue (no recursion) is used to store and explore the nodes. The game state where Pac-Man is farthest from the ghost is found. Depth-First Search is implemented similarly, but instead of a FIFO queue a LIFO stack is used to store game nodes. Iterative Deepening runs the Depth-First Algorithm for various depths using a simple for loop. This, however, runs quite slowly due to the large number of computations and states involved.

## Informed search
In A* Algorithm (informed tree search), the aim of Pac-Man is to move towards to nearest Power Pill irrespective of the ghosts. A special Game State node (AStarNode) is used which stores the game state, the move to get to the state, the distance from the source node (g) and the estimated heuristic (h) to the goal node (nearest power pill). Two queues openSet and closedSet are used to store nodes. The lowest cost (f=g+h) node is selected from the openSet using
getMinimumNode(). Thus, openSet acts like a priority queue. Successors of this state are produced and added to the openSet. Else they are compared according to their (f) values. A* algorithm succeeds in finding the shortest path to the power pill but does not consider the position of the ghosts.

## Optimization and Evolutionary Algorithms
Node class stores Game nodes and Pac-Man aims to move away from the ghosts. In Hill Climbing algorithm, successors of the initial state are generated and stored in a queue. The successors are compared with the initial state and with each other. The state which takes Pac-Man farthest from the ghosts is chosen as the next state. However, this algorithm suffers from local maxima which occurs when the Pac-Man is at the same distance from 2 or more ghosts. At this moment, the Pac-Man cannot risk going in either direction and therefore keeps oscillating. In Simulated Annealing, we define an initial temperature and a cooling rate. Then a random successor state is generated and it is selected if it improves the current state, else it is selected with a probability of e^(E/T). Math.Random() is used for this. For evolution strategy, we begin with a random generated set of moves. Successors of these moves are generated and the state corresponding to the best move is chosen. In genetic algorithms, we employ a crossover technique which combines two action sequences by replacing some moves by the successor moves.